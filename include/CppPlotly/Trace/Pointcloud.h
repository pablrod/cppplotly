/**
 * @file Pointcloud.h
This file has been autogenerated from the official plotly.js source.

If you like Plotly, please support them: L<https://plot.ly/> 
Open source announcement: L<https://plot.ly/javascript/open-source-announcement/>

Full reference: L<https://plot.ly/javascript/reference/#pointcloud>

This is an unofficial Plotly Perl module. Currently I'm not affiliated in any way with Plotly. 
But I think plotly.js is a great library and I want to use it with C++.
 *
 */
#include <vector>
#include <string>
#include <sstream>

#include <json11.hpp>

#include "../BaseTrace.h"

#include "CppPlotly/Trace/Pointcloud/Hoverlabel.h"
#include "CppPlotly/Trace/Pointcloud/Marker.h"
#include "CppPlotly/Trace/Pointcloud/Stream.h"


namespace CppPlotly {
    namespace Trace {
        /**
         * The data visualized as a point cloud set in `x` and `y` using the WebGl plotting engine.
         *
         *
         */ 
        class Pointcloud : public virtual CppPlotly::BaseTrace {
        public:
            Pointcloud() :
                            _pointcloud({
                                {"type", "pointcloud"},
                                    })
                        {}

           /**
Assigns extra data each datum. This may be useful when listening to hover, click and selection events. Note that, *scatter* traces also appends customdata items in the markers DOM elements
*/Pointcloud & Customdata(const std::vector<double> &customdata ) {
    _pointcloud.insert({"customdata", customdata});
    return *this;
}


/**
Assigns extra data each datum. This may be useful when listening to hover, click and selection events. Note that, *scatter* traces also appends customdata items in the markers DOM elements
*/Pointcloud & Customdata(const std::vector<std::string> &customdata ) {
    _pointcloud.insert({"customdata", customdata});
    return *this;
}


/**
Assigns extra data each datum. This may be useful when listening to hover, click and selection events. Note that, *scatter* traces also appends customdata items in the markers DOM elements
*/Pointcloud & Customdata(const json11::Json &customdata ) {
    _pointcloud.insert({"customdata", customdata});
    return *this;
}


/**
Sets the source reference on plot.ly for  customdata .
*/Pointcloud & Customdatasrc(const std::string &customdatasrc ) {
    _pointcloud.insert({"customdatasrc", customdatasrc});
    return *this;
}


/**
Determines which trace information appear on hover. If `none` or `skip` are set, no information is displayed upon hovering. But, if `none` is set, click and hover events are still fired.
*/Pointcloud & Hoverinfo(const json11::Json &hoverinfo ) {
    _pointcloud.insert({"hoverinfo", hoverinfo});
    return *this;
}


/**
Sets the source reference on plot.ly for  hoverinfo .
*/Pointcloud & Hoverinfosrc(const std::string &hoverinfosrc ) {
    _pointcloud.insert({"hoverinfosrc", hoverinfosrc});
    return *this;
}


Pointcloud & Hoverlabel(const CppPlotly::Trace::pointcloud::Hoverlabel &hoverlabel ) {
    _pointcloud.insert({"hoverlabel", hoverlabel});
    return *this;
}


/**
Assigns id labels to each datum. These ids for object constancy of data points during animation. Should be an array of strings, not numbers or any other type.
*/Pointcloud & Ids(const std::vector<double> &ids ) {
    _pointcloud.insert({"ids", ids});
    return *this;
}


/**
Assigns id labels to each datum. These ids for object constancy of data points during animation. Should be an array of strings, not numbers or any other type.
*/Pointcloud & Ids(const std::vector<std::string> &ids ) {
    _pointcloud.insert({"ids", ids});
    return *this;
}


/**
Assigns id labels to each datum. These ids for object constancy of data points during animation. Should be an array of strings, not numbers or any other type.
*/Pointcloud & Ids(const json11::Json &ids ) {
    _pointcloud.insert({"ids", ids});
    return *this;
}


/**
Sets the source reference on plot.ly for  ids .
*/Pointcloud & Idssrc(const std::string &idssrc ) {
    _pointcloud.insert({"idssrc", idssrc});
    return *this;
}


/**
A sequential value, 0..n, supply it to avoid creating this array inside plotting. If specified, it must be a typed `Int32Array` array. Its length must be equal to or greater than the number of points. For the best performance and memory use, create one large `indices` typed array that is guaranteed to be at least as long as the largest number of points during use, and reuse it on each `Plotly.restyle()` call.
*/Pointcloud & Indices(const std::vector<double> &indices ) {
    _pointcloud.insert({"indices", indices});
    return *this;
}


/**
A sequential value, 0..n, supply it to avoid creating this array inside plotting. If specified, it must be a typed `Int32Array` array. Its length must be equal to or greater than the number of points. For the best performance and memory use, create one large `indices` typed array that is guaranteed to be at least as long as the largest number of points during use, and reuse it on each `Plotly.restyle()` call.
*/Pointcloud & Indices(const std::vector<std::string> &indices ) {
    _pointcloud.insert({"indices", indices});
    return *this;
}


/**
A sequential value, 0..n, supply it to avoid creating this array inside plotting. If specified, it must be a typed `Int32Array` array. Its length must be equal to or greater than the number of points. For the best performance and memory use, create one large `indices` typed array that is guaranteed to be at least as long as the largest number of points during use, and reuse it on each `Plotly.restyle()` call.
*/Pointcloud & Indices(const json11::Json &indices ) {
    _pointcloud.insert({"indices", indices});
    return *this;
}


/**
Sets the source reference on plot.ly for  indices .
*/Pointcloud & Indicessrc(const std::string &indicessrc ) {
    _pointcloud.insert({"indicessrc", indicessrc});
    return *this;
}


/**
Sets the legend group for this trace. Traces part of the same legend group hide/show at the same time when toggling legend items.
*/Pointcloud & Legendgroup(const std::string &legendgroup ) {
    _pointcloud.insert({"legendgroup", legendgroup});
    return *this;
}


Pointcloud & Marker(const CppPlotly::Trace::pointcloud::Marker &marker ) {
    _pointcloud.insert({"marker", marker});
    return *this;
}


/**
Sets the trace name. The trace name appear as the legend item and on hover.
*/Pointcloud & Name(const std::string &name ) {
    _pointcloud.insert({"name", name});
    return *this;
}


/**
Sets the opacity of the trace.
*/Pointcloud & Opacity(const double &opacity ) {
    _pointcloud.insert({"opacity", opacity});
    return *this;
}


/**
Array containing integer indices of selected points. Has an effect only for traces that support selections. Note that an empty array means an empty selection where the `unselected` are turned on for all points, whereas, any other non-array values means no selection all where the `selected` and `unselected` styles have no effect.
*/Pointcloud & Selectedpoints(const json11::Json &selectedpoints ) {
    _pointcloud.insert({"selectedpoints", selectedpoints});
    return *this;
}


/**
Determines whether or not an item corresponding to this trace is shown in the legend.
*/Pointcloud & Showlegend(const bool &showlegend ) {
    _pointcloud.insert({"showlegend", showlegend});
    return *this;
}


Pointcloud & Stream(const CppPlotly::Trace::pointcloud::Stream &stream ) {
    _pointcloud.insert({"stream", stream});
    return *this;
}


/**
Sets text elements associated with each (x,y) pair. If a single string, the same string appears over all the data points. If an array of string, the items are mapped in order to the this trace's (x,y) coordinates. If trace `hoverinfo` contains a *text* flag and *hovertext* is not set, these elements will be seen in the hover labels.
*/Pointcloud & Text(const json11::Json &text ) {
    _pointcloud.insert({"text", text});
    return *this;
}


/**
Sets the source reference on plot.ly for  text .
*/Pointcloud & Textsrc(const std::string &textsrc ) {
    _pointcloud.insert({"textsrc", textsrc});
    return *this;
}


/**
Assign an id to this trace, Use this to provide object constancy between traces during animations and transitions.
*/Pointcloud & Uid(const std::string &uid ) {
    _pointcloud.insert({"uid", uid});
    return *this;
}


/**
Controls persistence of some user-driven changes to the trace: `constraintrange` in `parcoords` traces, as well as some `editable: true` modifications such as `name` and `colorbar.title`. Defaults to `layout.uirevision`. Note that other user-driven trace attribute changes are controlled by `layout` attributes: `trace.visible` is controlled by `layout.legend.uirevision`, `selectedpoints` is controlled by `layout.selectionrevision`, and `colorbar.(x|y)` (accessible with `config: {editable: true}`) is controlled by `layout.editrevision`. Trace changes are tracked by `uid`, which only falls back on trace index if no `uid` is provided. So if your app can add/remove traces before the end of the `data` array, such that the same trace has a different index, you can still preserve user-driven changes if you give each trace a `uid` that stays with it as it moves.
*/Pointcloud & Uirevision(const json11::Json &uirevision ) {
    _pointcloud.insert({"uirevision", uirevision});
    return *this;
}


/**
Determines whether or not this trace is visible. If *legendonly*, the trace is not drawn, but can appear as a legend item (provided that the legend itself is visible).
*/Pointcloud & Visible(const json11::Json &visible ) {
    _pointcloud.insert({"visible", visible});
    return *this;
}


/**
Sets the x coordinates.
*/Pointcloud & X(const std::vector<double> &x ) {
    _pointcloud.insert({"x", x});
    return *this;
}


/**
Sets the x coordinates.
*/Pointcloud & X(const std::vector<std::string> &x ) {
    _pointcloud.insert({"x", x});
    return *this;
}


/**
Sets the x coordinates.
*/Pointcloud & X(const json11::Json &x ) {
    _pointcloud.insert({"x", x});
    return *this;
}


/**
Sets a reference between this trace's x coordinates and a 2D cartesian x axis. If *x* (the default value), the x coordinates refer to `layout.xaxis`. If *x2*, the x coordinates refer to `layout.xaxis2`, and so on.
*/Pointcloud & Xaxis(const json11::Json &xaxis ) {
    _pointcloud.insert({"xaxis", xaxis});
    return *this;
}


/**
Specify `xbounds` in the shape of `[xMin, xMax] to avoid looping through the `xy` typed array. Use it in conjunction with `xy` and `ybounds` for the performance benefits.
*/Pointcloud & Xbounds(const std::vector<double> &xbounds ) {
    _pointcloud.insert({"xbounds", xbounds});
    return *this;
}


/**
Specify `xbounds` in the shape of `[xMin, xMax] to avoid looping through the `xy` typed array. Use it in conjunction with `xy` and `ybounds` for the performance benefits.
*/Pointcloud & Xbounds(const std::vector<std::string> &xbounds ) {
    _pointcloud.insert({"xbounds", xbounds});
    return *this;
}


/**
Specify `xbounds` in the shape of `[xMin, xMax] to avoid looping through the `xy` typed array. Use it in conjunction with `xy` and `ybounds` for the performance benefits.
*/Pointcloud & Xbounds(const json11::Json &xbounds ) {
    _pointcloud.insert({"xbounds", xbounds});
    return *this;
}


/**
Sets the source reference on plot.ly for  xbounds .
*/Pointcloud & Xboundssrc(const std::string &xboundssrc ) {
    _pointcloud.insert({"xboundssrc", xboundssrc});
    return *this;
}


/**
Sets the source reference on plot.ly for  x .
*/Pointcloud & Xsrc(const std::string &xsrc ) {
    _pointcloud.insert({"xsrc", xsrc});
    return *this;
}


/**
Faster alternative to specifying `x` and `y` separately. If supplied, it must be a typed `Float32Array` array that represents points such that `xy[i * 2] = x[i]` and `xy[i * 2 + 1] = y[i]`
*/Pointcloud & Xy(const std::vector<double> &xy ) {
    _pointcloud.insert({"xy", xy});
    return *this;
}


/**
Faster alternative to specifying `x` and `y` separately. If supplied, it must be a typed `Float32Array` array that represents points such that `xy[i * 2] = x[i]` and `xy[i * 2 + 1] = y[i]`
*/Pointcloud & Xy(const std::vector<std::string> &xy ) {
    _pointcloud.insert({"xy", xy});
    return *this;
}


/**
Faster alternative to specifying `x` and `y` separately. If supplied, it must be a typed `Float32Array` array that represents points such that `xy[i * 2] = x[i]` and `xy[i * 2 + 1] = y[i]`
*/Pointcloud & Xy(const json11::Json &xy ) {
    _pointcloud.insert({"xy", xy});
    return *this;
}


/**
Sets the source reference on plot.ly for  xy .
*/Pointcloud & Xysrc(const std::string &xysrc ) {
    _pointcloud.insert({"xysrc", xysrc});
    return *this;
}


/**
Sets the y coordinates.
*/Pointcloud & Y(const std::vector<double> &y ) {
    _pointcloud.insert({"y", y});
    return *this;
}


/**
Sets the y coordinates.
*/Pointcloud & Y(const std::vector<std::string> &y ) {
    _pointcloud.insert({"y", y});
    return *this;
}


/**
Sets the y coordinates.
*/Pointcloud & Y(const json11::Json &y ) {
    _pointcloud.insert({"y", y});
    return *this;
}


/**
Sets a reference between this trace's y coordinates and a 2D cartesian y axis. If *y* (the default value), the y coordinates refer to `layout.yaxis`. If *y2*, the y coordinates refer to `layout.yaxis2`, and so on.
*/Pointcloud & Yaxis(const json11::Json &yaxis ) {
    _pointcloud.insert({"yaxis", yaxis});
    return *this;
}


/**
Specify `ybounds` in the shape of `[yMin, yMax] to avoid looping through the `xy` typed array. Use it in conjunction with `xy` and `xbounds` for the performance benefits.
*/Pointcloud & Ybounds(const std::vector<double> &ybounds ) {
    _pointcloud.insert({"ybounds", ybounds});
    return *this;
}


/**
Specify `ybounds` in the shape of `[yMin, yMax] to avoid looping through the `xy` typed array. Use it in conjunction with `xy` and `xbounds` for the performance benefits.
*/Pointcloud & Ybounds(const std::vector<std::string> &ybounds ) {
    _pointcloud.insert({"ybounds", ybounds});
    return *this;
}


/**
Specify `ybounds` in the shape of `[yMin, yMax] to avoid looping through the `xy` typed array. Use it in conjunction with `xy` and `xbounds` for the performance benefits.
*/Pointcloud & Ybounds(const json11::Json &ybounds ) {
    _pointcloud.insert({"ybounds", ybounds});
    return *this;
}


/**
Sets the source reference on plot.ly for  ybounds .
*/Pointcloud & Yboundssrc(const std::string &yboundssrc ) {
    _pointcloud.insert({"yboundssrc", yboundssrc});
    return *this;
}


/**
Sets the source reference on plot.ly for  y .
*/Pointcloud & Ysrc(const std::string &ysrc ) {
    _pointcloud.insert({"ysrc", ysrc});
    return *this;
}


 

            virtual json11::Json to_json() const {
                return _pointcloud;
            }

        private:
            
            json11::Json::object _pointcloud;

        };
    }
}


