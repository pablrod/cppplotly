/**
 * @file Heatmap.h
This file has been autogenerated from the official plotly.js source.

If you like Plotly, please support them: L<https://plot.ly/> 
Open source announcement: L<https://plot.ly/javascript/open-source-announcement/>

Full reference: L<https://plot.ly/javascript/reference/#heatmap>

This is an unofficial Plotly Perl module. Currently I'm not affiliated in any way with Plotly. 
But I think plotly.js is a great library and I want to use it with C++.
 *
 */
#include <vector>
#include <string>
#include <sstream>

#include <json11.hpp>

#include "../BaseTrace.h"

#include "CppPlotly/Trace/Heatmap/Colorbar.h"
#include "CppPlotly/Trace/Heatmap/Hoverlabel.h"
#include "CppPlotly/Trace/Heatmap/Stream.h"
#include "CppPlotly/Trace/Heatmap/Transform.h"


namespace CppPlotly {
    namespace Trace {
        /**
         * The data that describes the heatmap value-to-color mapping is set in `z`. Data in `z` can either be a {2D array} of values (ragged or not) or a 1D array of values. In the case where `z` is a {2D array}, say that `z` has N rows and M columns. Then, by default, the resulting heatmap will have N partitions along the y axis and M partitions along the x axis. In other words, the i-th row/ j-th column cell in `z` is mapped to the i-th partition of the y axis (starting from the bottom of the plot) and the j-th partition of the x-axis (starting from the left of the plot). This behavior can be flipped by using `transpose`. Moreover, `x` (`y`) can be provided with M or M+1 (N or N+1) elements. If M (N), then the coordinates correspond to the center of the heatmap cells and the cells have equal width. If M+1 (N+1), then the coordinates correspond to the edges of the heatmap cells. In the case where `z` is a 1D {array}, the x and y coordinates must be provided in `x` and `y` respectively to form data triplets.
         *
         *
         */ 
        class Heatmap : public virtual CppPlotly::BaseTrace {
        public:
            Heatmap() :
                            _heatmap({
                                {"type", "heatmap"},
                                    })
                        {}

           /**
Determines whether the colorscale is a default palette (`autocolorscale: true`) or the palette determined by `colorscale`. In case `colorscale` is unspecified or `autocolorscale` is true, the default  palette will be chosen according to whether numbers in the `color` array are all positive, all negative or mixed.
*/Heatmap & Autocolorscale(const bool &autocolorscale ) {
    _heatmap.insert({"autocolorscale", autocolorscale});
    return *this;
}


Heatmap & Colorbar(const CppPlotly::Trace::heatmap::Colorbar &colorbar ) {
    _heatmap.insert({"colorbar", colorbar});
    return *this;
}


/**
Sets the colorscale. The colorscale must be an array containing arrays mapping a normalized value to an rgb, rgba, hex, hsl, hsv, or named color string. At minimum, a mapping for the lowest (0) and highest (1) values are required. For example, `[[0, 'rgb(0,0,255)', [1, 'rgb(255,0,0)']]`. To control the bounds of the colorscale in color space, use`zmin` and `zmax`. Alternatively, `colorscale` may be a palette name string of the following list: Greys,YlGnBu,Greens,YlOrRd,Bluered,RdBu,Reds,Blues,Picnic,Rainbow,Portland,Jet,Hot,Blackbody,Earth,Electric,Viridis,Cividis.
*/Heatmap & Colorscale(const json11::Json &colorscale ) {
    _heatmap.insert({"colorscale", colorscale});
    return *this;
}


/**
Determines whether or not gaps (i.e. {nan} or missing values) in the `z` data are filled in.
*/Heatmap & Connectgaps(const bool &connectgaps ) {
    _heatmap.insert({"connectgaps", connectgaps});
    return *this;
}


/**
Assigns extra data each datum. This may be useful when listening to hover, click and selection events. Note that, *scatter* traces also appends customdata items in the markers DOM elements
*/Heatmap & Customdata(const std::vector<double> &customdata ) {
    _heatmap.insert({"customdata", customdata});
    return *this;
}


/**
Assigns extra data each datum. This may be useful when listening to hover, click and selection events. Note that, *scatter* traces also appends customdata items in the markers DOM elements
*/Heatmap & Customdata(const std::vector<std::string> &customdata ) {
    _heatmap.insert({"customdata", customdata});
    return *this;
}


/**
Assigns extra data each datum. This may be useful when listening to hover, click and selection events. Note that, *scatter* traces also appends customdata items in the markers DOM elements
*/Heatmap & Customdata(const json11::Json &customdata ) {
    _heatmap.insert({"customdata", customdata});
    return *this;
}


/**
Sets the source reference on plot.ly for  customdata .
*/Heatmap & Customdatasrc(const std::string &customdatasrc ) {
    _heatmap.insert({"customdatasrc", customdatasrc});
    return *this;
}


/**
Sets the x coordinate step. See `x0` for more info.
*/Heatmap & Dx(const double &dx ) {
    _heatmap.insert({"dx", dx});
    return *this;
}


/**
Sets the y coordinate step. See `y0` for more info.
*/Heatmap & Dy(const double &dy ) {
    _heatmap.insert({"dy", dy});
    return *this;
}


/**
Determines which trace information appear on hover. If `none` or `skip` are set, no information is displayed upon hovering. But, if `none` is set, click and hover events are still fired.
*/Heatmap & Hoverinfo(const json11::Json &hoverinfo ) {
    _heatmap.insert({"hoverinfo", hoverinfo});
    return *this;
}


/**
Sets the source reference on plot.ly for  hoverinfo .
*/Heatmap & Hoverinfosrc(const std::string &hoverinfosrc ) {
    _heatmap.insert({"hoverinfosrc", hoverinfosrc});
    return *this;
}


Heatmap & Hoverlabel(const CppPlotly::Trace::heatmap::Hoverlabel &hoverlabel ) {
    _heatmap.insert({"hoverlabel", hoverlabel});
    return *this;
}


/**
Template string used for rendering the information that appear on hover box. Note that this will override `hoverinfo`. Variables are inserted using %{variable}, for example "y: %{y}". Numbers are formatted using d3-format's syntax %{variable:d3-format}, for example "Price: %{y:$.2f}". See https://github.com/d3/d3-format/blob/master/README.md#locale_format for details on the formatting syntax. The variables available in `hovertemplate` are the ones emitted as event data described at this link https://plot.ly/javascript/plotlyjs-events/#event-data. Additionally, every attributes that can be specified per-point (the ones that are `arrayOk: true`) are available.  Anything contained in tag `<extra>` is displayed in the secondary box, for example "<extra>{fullData.name}</extra>". To hide the secondary box completely, use an empty tag `<extra></extra>`.
*/Heatmap & Hovertemplate(const json11::Json &hovertemplate ) {
    _heatmap.insert({"hovertemplate", hovertemplate});
    return *this;
}


/**
Sets the source reference on plot.ly for  hovertemplate .
*/Heatmap & Hovertemplatesrc(const std::string &hovertemplatesrc ) {
    _heatmap.insert({"hovertemplatesrc", hovertemplatesrc});
    return *this;
}


/**
Same as `text`.
*/Heatmap & Hovertext(const std::vector<double> &hovertext ) {
    _heatmap.insert({"hovertext", hovertext});
    return *this;
}


/**
Same as `text`.
*/Heatmap & Hovertext(const std::vector<std::string> &hovertext ) {
    _heatmap.insert({"hovertext", hovertext});
    return *this;
}


/**
Same as `text`.
*/Heatmap & Hovertext(const json11::Json &hovertext ) {
    _heatmap.insert({"hovertext", hovertext});
    return *this;
}


/**
Sets the source reference on plot.ly for  hovertext .
*/Heatmap & Hovertextsrc(const std::string &hovertextsrc ) {
    _heatmap.insert({"hovertextsrc", hovertextsrc});
    return *this;
}


/**
Assigns id labels to each datum. These ids for object constancy of data points during animation. Should be an array of strings, not numbers or any other type.
*/Heatmap & Ids(const std::vector<double> &ids ) {
    _heatmap.insert({"ids", ids});
    return *this;
}


/**
Assigns id labels to each datum. These ids for object constancy of data points during animation. Should be an array of strings, not numbers or any other type.
*/Heatmap & Ids(const std::vector<std::string> &ids ) {
    _heatmap.insert({"ids", ids});
    return *this;
}


/**
Assigns id labels to each datum. These ids for object constancy of data points during animation. Should be an array of strings, not numbers or any other type.
*/Heatmap & Ids(const json11::Json &ids ) {
    _heatmap.insert({"ids", ids});
    return *this;
}


/**
Sets the source reference on plot.ly for  ids .
*/Heatmap & Idssrc(const std::string &idssrc ) {
    _heatmap.insert({"idssrc", idssrc});
    return *this;
}


/**
Sets the legend group for this trace. Traces part of the same legend group hide/show at the same time when toggling legend items.
*/Heatmap & Legendgroup(const std::string &legendgroup ) {
    _heatmap.insert({"legendgroup", legendgroup});
    return *this;
}


/**
Sets the trace name. The trace name appear as the legend item and on hover.
*/Heatmap & Name(const std::string &name ) {
    _heatmap.insert({"name", name});
    return *this;
}


/**
Sets the opacity of the trace.
*/Heatmap & Opacity(const double &opacity ) {
    _heatmap.insert({"opacity", opacity});
    return *this;
}


/**
Reverses the color mapping if true. If true, `zmin` will correspond to the last color in the array and `zmax` will correspond to the first color.
*/Heatmap & Reversescale(const bool &reversescale ) {
    _heatmap.insert({"reversescale", reversescale});
    return *this;
}


/**
Array containing integer indices of selected points. Has an effect only for traces that support selections. Note that an empty array means an empty selection where the `unselected` are turned on for all points, whereas, any other non-array values means no selection all where the `selected` and `unselected` styles have no effect.
*/Heatmap & Selectedpoints(const json11::Json &selectedpoints ) {
    _heatmap.insert({"selectedpoints", selectedpoints});
    return *this;
}


/**
Determines whether or not an item corresponding to this trace is shown in the legend.
*/Heatmap & Showlegend(const bool &showlegend ) {
    _heatmap.insert({"showlegend", showlegend});
    return *this;
}


/**
Determines whether or not a colorbar is displayed for this trace.
*/Heatmap & Showscale(const bool &showscale ) {
    _heatmap.insert({"showscale", showscale});
    return *this;
}


Heatmap & Stream(const CppPlotly::Trace::heatmap::Stream &stream ) {
    _heatmap.insert({"stream", stream});
    return *this;
}


/**
Sets the text elements associated with each z value.
*/Heatmap & Text(const std::vector<double> &text ) {
    _heatmap.insert({"text", text});
    return *this;
}


/**
Sets the text elements associated with each z value.
*/Heatmap & Text(const std::vector<std::string> &text ) {
    _heatmap.insert({"text", text});
    return *this;
}


/**
Sets the text elements associated with each z value.
*/Heatmap & Text(const json11::Json &text ) {
    _heatmap.insert({"text", text});
    return *this;
}


/**
Sets the source reference on plot.ly for  text .
*/Heatmap & Textsrc(const std::string &textsrc ) {
    _heatmap.insert({"textsrc", textsrc});
    return *this;
}


Heatmap & Transforms(const std::vector<CppPlotly::Trace::heatmap::Transform> &transforms ) {
    _heatmap.insert({"transforms", transforms});
    return *this;
}


/**
Transposes the z data.
*/Heatmap & Transpose(const bool &transpose ) {
    _heatmap.insert({"transpose", transpose});
    return *this;
}


/**
Assign an id to this trace, Use this to provide object constancy between traces during animations and transitions.
*/Heatmap & Uid(const std::string &uid ) {
    _heatmap.insert({"uid", uid});
    return *this;
}


/**
Controls persistence of some user-driven changes to the trace: `constraintrange` in `parcoords` traces, as well as some `editable: true` modifications such as `name` and `colorbar.title`. Defaults to `layout.uirevision`. Note that other user-driven trace attribute changes are controlled by `layout` attributes: `trace.visible` is controlled by `layout.legend.uirevision`, `selectedpoints` is controlled by `layout.selectionrevision`, and `colorbar.(x|y)` (accessible with `config: {editable: true}`) is controlled by `layout.editrevision`. Trace changes are tracked by `uid`, which only falls back on trace index if no `uid` is provided. So if your app can add/remove traces before the end of the `data` array, such that the same trace has a different index, you can still preserve user-driven changes if you give each trace a `uid` that stays with it as it moves.
*/Heatmap & Uirevision(const json11::Json &uirevision ) {
    _heatmap.insert({"uirevision", uirevision});
    return *this;
}


/**
Determines whether or not this trace is visible. If *legendonly*, the trace is not drawn, but can appear as a legend item (provided that the legend itself is visible).
*/Heatmap & Visible(const json11::Json &visible ) {
    _heatmap.insert({"visible", visible});
    return *this;
}


/**
Sets the x coordinates.
*/Heatmap & X(const std::vector<double> &x ) {
    _heatmap.insert({"x", x});
    return *this;
}


/**
Sets the x coordinates.
*/Heatmap & X(const std::vector<std::string> &x ) {
    _heatmap.insert({"x", x});
    return *this;
}


/**
Sets the x coordinates.
*/Heatmap & X(const json11::Json &x ) {
    _heatmap.insert({"x", x});
    return *this;
}


/**
Alternate to `x`. Builds a linear space of x coordinates. Use with `dx` where `x0` is the starting coordinate and `dx` the step.
*/Heatmap & X0(const json11::Json &x0 ) {
    _heatmap.insert({"x0", x0});
    return *this;
}


/**
Sets a reference between this trace's x coordinates and a 2D cartesian x axis. If *x* (the default value), the x coordinates refer to `layout.xaxis`. If *x2*, the x coordinates refer to `layout.xaxis2`, and so on.
*/Heatmap & Xaxis(const json11::Json &xaxis ) {
    _heatmap.insert({"xaxis", xaxis});
    return *this;
}


/**
Sets the calendar system to use with `x` date data.
*/Heatmap & Xcalendar(const json11::Json &xcalendar ) {
    _heatmap.insert({"xcalendar", xcalendar});
    return *this;
}


/**
Sets the horizontal gap (in pixels) between bricks.
*/Heatmap & Xgap(const double &xgap ) {
    _heatmap.insert({"xgap", xgap});
    return *this;
}


/**
Sets the source reference on plot.ly for  x .
*/Heatmap & Xsrc(const std::string &xsrc ) {
    _heatmap.insert({"xsrc", xsrc});
    return *this;
}


/**
If *array*, the heatmap's x coordinates are given by *x* (the default behavior when `x` is provided). If *scaled*, the heatmap's x coordinates are given by *x0* and *dx* (the default behavior when `x` is not provided).
*/Heatmap & Xtype(const json11::Json &xtype ) {
    _heatmap.insert({"xtype", xtype});
    return *this;
}


/**
Sets the y coordinates.
*/Heatmap & Y(const std::vector<double> &y ) {
    _heatmap.insert({"y", y});
    return *this;
}


/**
Sets the y coordinates.
*/Heatmap & Y(const std::vector<std::string> &y ) {
    _heatmap.insert({"y", y});
    return *this;
}


/**
Sets the y coordinates.
*/Heatmap & Y(const json11::Json &y ) {
    _heatmap.insert({"y", y});
    return *this;
}


/**
Alternate to `y`. Builds a linear space of y coordinates. Use with `dy` where `y0` is the starting coordinate and `dy` the step.
*/Heatmap & Y0(const json11::Json &y0 ) {
    _heatmap.insert({"y0", y0});
    return *this;
}


/**
Sets a reference between this trace's y coordinates and a 2D cartesian y axis. If *y* (the default value), the y coordinates refer to `layout.yaxis`. If *y2*, the y coordinates refer to `layout.yaxis2`, and so on.
*/Heatmap & Yaxis(const json11::Json &yaxis ) {
    _heatmap.insert({"yaxis", yaxis});
    return *this;
}


/**
Sets the calendar system to use with `y` date data.
*/Heatmap & Ycalendar(const json11::Json &ycalendar ) {
    _heatmap.insert({"ycalendar", ycalendar});
    return *this;
}


/**
Sets the vertical gap (in pixels) between bricks.
*/Heatmap & Ygap(const double &ygap ) {
    _heatmap.insert({"ygap", ygap});
    return *this;
}


/**
Sets the source reference on plot.ly for  y .
*/Heatmap & Ysrc(const std::string &ysrc ) {
    _heatmap.insert({"ysrc", ysrc});
    return *this;
}


/**
If *array*, the heatmap's y coordinates are given by *y* (the default behavior when `y` is provided) If *scaled*, the heatmap's y coordinates are given by *y0* and *dy* (the default behavior when `y` is not provided)
*/Heatmap & Ytype(const json11::Json &ytype ) {
    _heatmap.insert({"ytype", ytype});
    return *this;
}


/**
Sets the z data.
*/Heatmap & Z(const std::vector<double> &z ) {
    _heatmap.insert({"z", z});
    return *this;
}


/**
Sets the z data.
*/Heatmap & Z(const std::vector<std::string> &z ) {
    _heatmap.insert({"z", z});
    return *this;
}


/**
Sets the z data.
*/Heatmap & Z(const json11::Json &z ) {
    _heatmap.insert({"z", z});
    return *this;
}


/**
Determines whether or not the color domain is computed with respect to the input data (here in `z`) or the bounds set in `zmin` and `zmax`  Defaults to `false` when `zmin` and `zmax` are set by the user.
*/Heatmap & Zauto(const bool &zauto ) {
    _heatmap.insert({"zauto", zauto});
    return *this;
}


/**
Sets the hover text formatting rule using d3 formatting mini-languages which are very similar to those in Python. See: https://github.com/d3/d3-format/blob/master/README.md#locale_format
*/Heatmap & Zhoverformat(const std::string &zhoverformat ) {
    _heatmap.insert({"zhoverformat", zhoverformat});
    return *this;
}


/**
Sets the upper bound of the color domain. Value should have the same units as in `z` and if set, `zmin` must be set as well.
*/Heatmap & Zmax(const double &zmax ) {
    _heatmap.insert({"zmax", zmax});
    return *this;
}


/**
Sets the mid-point of the color domain by scaling `zmin` and/or `zmax` to be equidistant to this point. Value should have the same units as in `z`. Has no effect when `zauto` is `false`.
*/Heatmap & Zmid(const double &zmid ) {
    _heatmap.insert({"zmid", zmid});
    return *this;
}


/**
Sets the lower bound of the color domain. Value should have the same units as in `z` and if set, `zmax` must be set as well.
*/Heatmap & Zmin(const double &zmin ) {
    _heatmap.insert({"zmin", zmin});
    return *this;
}


/**
Picks a smoothing algorithm use to smooth `z` data.
*/Heatmap & Zsmooth(const json11::Json &zsmooth ) {
    _heatmap.insert({"zsmooth", zsmooth});
    return *this;
}


/**
Sets the source reference on plot.ly for  z .
*/Heatmap & Zsrc(const std::string &zsrc ) {
    _heatmap.insert({"zsrc", zsrc});
    return *this;
}


 

            virtual json11::Json to_json() const {
                return _heatmap;
            }

        private:
            
            json11::Json::object _heatmap;

        };
    }
}


