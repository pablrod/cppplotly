/**
 * @file Parcats.h
This file has been autogenerated from the official plotly.js source.

If you like Plotly, please support them: L<https://plot.ly/> 
Open source announcement: L<https://plot.ly/javascript/open-source-announcement/>

Full reference: L<https://plot.ly/javascript/reference/#parcats>

This is an unofficial Plotly Perl module. Currently I'm not affiliated in any way with Plotly. 
But I think plotly.js is a great library and I want to use it with C++.
 *
 */
#include <vector>
#include <string>
#include <sstream>

#include <json11.hpp>

#include "../BaseTrace.h"

#include "CppPlotly/Trace/Parcats/Dimension.h"
#include "CppPlotly/Trace/Parcats/Domain.h"
#include "CppPlotly/Trace/Parcats/Labelfont.h"
#include "CppPlotly/Trace/Parcats/Line.h"
#include "CppPlotly/Trace/Parcats/Stream.h"
#include "CppPlotly/Trace/Parcats/Tickfont.h"
#include "CppPlotly/Trace/Parcats/Transform.h"


namespace CppPlotly {
    namespace Trace {
        /**
         * Parallel categories diagram for multidimensional categorical data.
         *
         *
         */ 
        class Parcats : public virtual CppPlotly::BaseTrace {
        public:
            Parcats() :
                            _parcats({
                                {"type", "parcats"},
                                    })
                        {}

           /**
Sets the drag interaction mode for categories and dimensions. If `perpendicular`, the categories can only move along a line perpendicular to the paths. If `freeform`, the categories can freely move on the plane. If `fixed`, the categories and dimensions are stationary.
*/Parcats & Arrangement(const json11::Json &arrangement ) {
    _parcats.insert({"arrangement", arrangement});
    return *this;
}


/**
Sort paths so that like colors are bundled together within each category.
*/Parcats & Bundlecolors(const bool &bundlecolors ) {
    _parcats.insert({"bundlecolors", bundlecolors});
    return *this;
}


/**
The number of observations represented by each state. Defaults to 1 so that each state represents one observation
*/Parcats & Counts(const json11::Json &counts ) {
    _parcats.insert({"counts", counts});
    return *this;
}


/**
Sets the source reference on plot.ly for  counts .
*/Parcats & Countssrc(const std::string &countssrc ) {
    _parcats.insert({"countssrc", countssrc});
    return *this;
}


Parcats & Dimensions(const std::vector<CppPlotly::Trace::parcats::Dimension> &dimensions ) {
    _parcats.insert({"dimensions", dimensions});
    return *this;
}


Parcats & Domain(const CppPlotly::Trace::parcats::Domain &domain ) {
    _parcats.insert({"domain", domain});
    return *this;
}


/**
Determines which trace information appear on hover. If `none` or `skip` are set, no information is displayed upon hovering. But, if `none` is set, click and hover events are still fired.
*/Parcats & Hoverinfo(const json11::Json &hoverinfo ) {
    _parcats.insert({"hoverinfo", hoverinfo});
    return *this;
}


/**
Sets the hover interaction mode for the parcats diagram. If `category`, hover interaction take place per category. If `color`, hover interactions take place per color per category. If `dimension`, hover interactions take place across all categories per dimension.
*/Parcats & Hoveron(const json11::Json &hoveron ) {
    _parcats.insert({"hoveron", hoveron});
    return *this;
}


/**
Template string used for rendering the information that appear on hover box. Note that this will override `hoverinfo`. Variables are inserted using %{variable}, for example "y: %{y}". Numbers are formatted using d3-format's syntax %{variable:d3-format}, for example "Price: %{y:$.2f}". See https://github.com/d3/d3-format/blob/master/README.md#locale_format for details on the formatting syntax. The variables available in `hovertemplate` are the ones emitted as event data described at this link https://plot.ly/javascript/plotlyjs-events/#event-data. Additionally, every attributes that can be specified per-point (the ones that are `arrayOk: true`) are available. variables `count`, `probability`, `category`, `categorycount`, `colorcount` and `bandcolorcount`. Anything contained in tag `<extra>` is displayed in the secondary box, for example "<extra>{fullData.name}</extra>". To hide the secondary box completely, use an empty tag `<extra></extra>`.
*/Parcats & Hovertemplate(const std::string &hovertemplate ) {
    _parcats.insert({"hovertemplate", hovertemplate});
    return *this;
}


Parcats & Labelfont(const CppPlotly::Trace::parcats::Labelfont &labelfont ) {
    _parcats.insert({"labelfont", labelfont});
    return *this;
}


Parcats & Line(const CppPlotly::Trace::parcats::Line &line ) {
    _parcats.insert({"line", line});
    return *this;
}


/**
Sets the trace name. The trace name appear as the legend item and on hover.
*/Parcats & Name(const std::string &name ) {
    _parcats.insert({"name", name});
    return *this;
}


/**
Sets the path sorting algorithm. If `forward`, sort paths based on dimension categories from left to right. If `backward`, sort paths based on dimensions categories from right to left.
*/Parcats & Sortpaths(const json11::Json &sortpaths ) {
    _parcats.insert({"sortpaths", sortpaths});
    return *this;
}


Parcats & Stream(const CppPlotly::Trace::parcats::Stream &stream ) {
    _parcats.insert({"stream", stream});
    return *this;
}


Parcats & Tickfont(const CppPlotly::Trace::parcats::Tickfont &tickfont ) {
    _parcats.insert({"tickfont", tickfont});
    return *this;
}


Parcats & Transforms(const std::vector<CppPlotly::Trace::parcats::Transform> &transforms ) {
    _parcats.insert({"transforms", transforms});
    return *this;
}


/**
Assign an id to this trace, Use this to provide object constancy between traces during animations and transitions.
*/Parcats & Uid(const std::string &uid ) {
    _parcats.insert({"uid", uid});
    return *this;
}


/**
Controls persistence of some user-driven changes to the trace: `constraintrange` in `parcoords` traces, as well as some `editable: true` modifications such as `name` and `colorbar.title`. Defaults to `layout.uirevision`. Note that other user-driven trace attribute changes are controlled by `layout` attributes: `trace.visible` is controlled by `layout.legend.uirevision`, `selectedpoints` is controlled by `layout.selectionrevision`, and `colorbar.(x|y)` (accessible with `config: {editable: true}`) is controlled by `layout.editrevision`. Trace changes are tracked by `uid`, which only falls back on trace index if no `uid` is provided. So if your app can add/remove traces before the end of the `data` array, such that the same trace has a different index, you can still preserve user-driven changes if you give each trace a `uid` that stays with it as it moves.
*/Parcats & Uirevision(const json11::Json &uirevision ) {
    _parcats.insert({"uirevision", uirevision});
    return *this;
}


/**
Determines whether or not this trace is visible. If *legendonly*, the trace is not drawn, but can appear as a legend item (provided that the legend itself is visible).
*/Parcats & Visible(const json11::Json &visible ) {
    _parcats.insert({"visible", visible});
    return *this;
}


 

            virtual json11::Json to_json() const {
                return _parcats;
            }

        private:
            
            json11::Json::object _parcats;

        };
    }
}


