/**
 * @file Aaxis.h
This attribute is part of the possible options for the trace carpet.

This file has been autogenerated from the official plotly.js source.

If you like Plotly, please support them: L<https://plot.ly/> 
Open source announcement: L<https://plot.ly/javascript/open-source-announcement/>

Full reference: L<https://plot.ly/javascript/reference/#carpet>

DISCLAIMER

This is an unofficial Plotly Perl module. Currently I'm not affiliated in any way with Plotly. 
But I think plotly.js is a great library and I want to use it with C++.

*/

#include <vector>
#include <string>
#include <sstream>

#include <json11.hpp>

#include "CppPlotly/Trace/Carpet/Aaxis/Tickfont.h"
#include "CppPlotly/Trace/Carpet/Aaxis/Tickformatstop.h"
#include "CppPlotly/Trace/Carpet/Aaxis/Titlefont.h"



namespace CppPlotly {
    namespace Trace {
    namespace carpet {

    /**
     * 
     *
     *
     */
    class Aaxis {
    public:

    /**
The stride between grid lines along the axis
*/Aaxis & Arraydtick(const int &arraydtick ) {
    _aaxis.insert({"arraydtick", arraydtick});
    return *this;
}


/**
The starting index of grid lines along the axis
*/Aaxis & Arraytick0(const int &arraytick0 ) {
    _aaxis.insert({"arraytick0", arraytick0});
    return *this;
}


/**
Determines whether or not the range of this axis is computed in relation to the input data. See `rangemode` for more info. If `range` is provided, then `autorange` is set to *false*.
*/Aaxis & Autorange(const json11::Json::object &autorange ) {
    _aaxis.insert({"autorange", autorange});
    return *this;
}


/**
Sets the order in which categories on this axis appear. Only has an effect if `categoryorder` is set to *array*. Used with `categoryorder`.
*/Aaxis & Categoryarray(const std::vector<double> &categoryarray ) {
    _aaxis.insert({"categoryarray", categoryarray});
    return *this;
}


/**
Sets the order in which categories on this axis appear. Only has an effect if `categoryorder` is set to *array*. Used with `categoryorder`.
*/Aaxis & Categoryarray(const std::vector<std::string> &categoryarray ) {
    _aaxis.insert({"categoryarray", categoryarray});
    return *this;
}


/**
Sets the order in which categories on this axis appear. Only has an effect if `categoryorder` is set to *array*. Used with `categoryorder`.
*/Aaxis & Categoryarray(const json11::Json::object &categoryarray ) {
    _aaxis.insert({"categoryarray", categoryarray});
    return *this;
}


/**
Sets the source reference on plot.ly for  categoryarray .
*/Aaxis & Categoryarraysrc(const std::string &categoryarraysrc ) {
    _aaxis.insert({"categoryarraysrc", categoryarraysrc});
    return *this;
}


/**
Specifies the ordering logic for the case of categorical variables. By default, plotly uses *trace*, which specifies the order that is present in the data supplied. Set `categoryorder` to *category ascending* or *category descending* if order should be determined by the alphanumerical order of the category names. Set `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category is not found in the `categoryarray` array, the sorting behavior for that attribute will be identical to the *trace* mode. The unspecified categories will follow the categories in `categoryarray`.
*/Aaxis & Categoryorder(const json11::Json::object &categoryorder ) {
    _aaxis.insert({"categoryorder", categoryorder});
    return *this;
}


Aaxis & Cheatertype(const json11::Json::object &cheatertype ) {
    _aaxis.insert({"cheatertype", cheatertype});
    return *this;
}


/**
Sets default for all colors associated with this axis all at once: line, font, tick, and grid colors. Grid color is lightened by blending this with the plot background Individual pieces can override this.
*/Aaxis & Color(const json11::Json::object &color ) {
    _aaxis.insert({"color", color});
    return *this;
}


/**
The stride between grid lines along the axis
*/Aaxis & Dtick(const double &dtick ) {
    _aaxis.insert({"dtick", dtick});
    return *this;
}


/**
Determines whether or not a line is drawn at along the final value of this axis. If *true*, the end line is drawn on top of the grid lines.
*/Aaxis & Endline(const bool &endline ) {
    _aaxis.insert({"endline", endline});
    return *this;
}


/**
Sets the line color of the end line.
*/Aaxis & Endlinecolor(const json11::Json::object &endlinecolor ) {
    _aaxis.insert({"endlinecolor", endlinecolor});
    return *this;
}


/**
Sets the width (in px) of the end line.
*/Aaxis & Endlinewidth(const double &endlinewidth ) {
    _aaxis.insert({"endlinewidth", endlinewidth});
    return *this;
}


/**
Determines a formatting rule for the tick exponents. For example, consider the number 1,000,000,000. If *none*, it appears as 1,000,000,000. If *e*, 1e+9. If *E*, 1E+9. If *power*, 1x10^9 (with 9 in a super script). If *SI*, 1G. If *B*, 1B.
*/Aaxis & Exponentformat(const json11::Json::object &exponentformat ) {
    _aaxis.insert({"exponentformat", exponentformat});
    return *this;
}


/**
Determines whether or not this axis is zoom-able. If true, then zoom is disabled.
*/Aaxis & Fixedrange(const bool &fixedrange ) {
    _aaxis.insert({"fixedrange", fixedrange});
    return *this;
}


/**
Sets the axis line color.
*/Aaxis & Gridcolor(const json11::Json::object &gridcolor ) {
    _aaxis.insert({"gridcolor", gridcolor});
    return *this;
}


/**
Sets the width (in px) of the axis line.
*/Aaxis & Gridwidth(const double &gridwidth ) {
    _aaxis.insert({"gridwidth", gridwidth});
    return *this;
}


/**
Extra padding between label and the axis
*/Aaxis & Labelpadding(const int &labelpadding ) {
    _aaxis.insert({"labelpadding", labelpadding});
    return *this;
}


/**
Sets a axis label prefix.
*/Aaxis & Labelprefix(const std::string &labelprefix ) {
    _aaxis.insert({"labelprefix", labelprefix});
    return *this;
}


/**
Sets a axis label suffix.
*/Aaxis & Labelsuffix(const std::string &labelsuffix ) {
    _aaxis.insert({"labelsuffix", labelsuffix});
    return *this;
}


/**
Sets the axis line color.
*/Aaxis & Linecolor(const json11::Json::object &linecolor ) {
    _aaxis.insert({"linecolor", linecolor});
    return *this;
}


/**
Sets the width (in px) of the axis line.
*/Aaxis & Linewidth(const double &linewidth ) {
    _aaxis.insert({"linewidth", linewidth});
    return *this;
}


/**
Sets the color of the grid lines.
*/Aaxis & Minorgridcolor(const json11::Json::object &minorgridcolor ) {
    _aaxis.insert({"minorgridcolor", minorgridcolor});
    return *this;
}


/**
Sets the number of minor grid ticks per major grid tick
*/Aaxis & Minorgridcount(const int &minorgridcount ) {
    _aaxis.insert({"minorgridcount", minorgridcount});
    return *this;
}


/**
Sets the width (in px) of the grid lines.
*/Aaxis & Minorgridwidth(const double &minorgridwidth ) {
    _aaxis.insert({"minorgridwidth", minorgridwidth});
    return *this;
}


/**
Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to *auto*.
*/Aaxis & Nticks(const int &nticks ) {
    _aaxis.insert({"nticks", nticks});
    return *this;
}


/**
Sets the range of this axis. If the axis `type` is *log*, then you must take the log of your desired range (e.g. to set the range from 1 to 100, set the range from 0 to 2). If the axis `type` is *date*, it should be date strings, like date data, though Date objects and unix milliseconds will be accepted and converted to strings. If the axis `type` is *category*, it should be numbers, using the scale where each category is assigned a serial number from zero in the order it appears.
*/Aaxis & Range(const std::vector<std::string> &range ) {
    _aaxis.insert({"range", range});
    return *this;
}


/**
If *normal*, the range is computed in relation to the extrema of the input data. If *tozero*`, the range extends to 0, regardless of the input data If *nonnegative*, the range is non-negative, regardless of the input data.
*/Aaxis & Rangemode(const json11::Json::object &rangemode ) {
    _aaxis.insert({"rangemode", rangemode});
    return *this;
}


/**
If "true", even 4-digit integers are separated
*/Aaxis & Separatethousands(const bool &separatethousands ) {
    _aaxis.insert({"separatethousands", separatethousands});
    return *this;
}


/**
If *all*, all exponents are shown besides their significands. If *first*, only the exponent of the first tick is shown. If *last*, only the exponent of the last tick is shown. If *none*, no exponents appear.
*/Aaxis & Showexponent(const json11::Json::object &showexponent ) {
    _aaxis.insert({"showexponent", showexponent});
    return *this;
}


/**
Determines whether or not grid lines are drawn. If *true*, the grid lines are drawn at every tick mark.
*/Aaxis & Showgrid(const bool &showgrid ) {
    _aaxis.insert({"showgrid", showgrid});
    return *this;
}


/**
Determines whether or not a line bounding this axis is drawn.
*/Aaxis & Showline(const bool &showline ) {
    _aaxis.insert({"showline", showline});
    return *this;
}


/**
Determines whether axis labels are drawn on the low side, the high side, both, or neither side of the axis.
*/Aaxis & Showticklabels(const json11::Json::object &showticklabels ) {
    _aaxis.insert({"showticklabels", showticklabels});
    return *this;
}


/**
If *all*, all tick labels are displayed with a prefix. If *first*, only the first tick is displayed with a prefix. If *last*, only the last tick is displayed with a suffix. If *none*, tick prefixes are hidden.
*/Aaxis & Showtickprefix(const json11::Json::object &showtickprefix ) {
    _aaxis.insert({"showtickprefix", showtickprefix});
    return *this;
}


/**
Same as `showtickprefix` but for tick suffixes.
*/Aaxis & Showticksuffix(const json11::Json::object &showticksuffix ) {
    _aaxis.insert({"showticksuffix", showticksuffix});
    return *this;
}


Aaxis & Smoothing(const double &smoothing ) {
    _aaxis.insert({"smoothing", smoothing});
    return *this;
}


/**
Determines whether or not a line is drawn at along the starting value of this axis. If *true*, the start line is drawn on top of the grid lines.
*/Aaxis & Startline(const bool &startline ) {
    _aaxis.insert({"startline", startline});
    return *this;
}


/**
Sets the line color of the start line.
*/Aaxis & Startlinecolor(const json11::Json::object &startlinecolor ) {
    _aaxis.insert({"startlinecolor", startlinecolor});
    return *this;
}


/**
Sets the width (in px) of the start line.
*/Aaxis & Startlinewidth(const double &startlinewidth ) {
    _aaxis.insert({"startlinewidth", startlinewidth});
    return *this;
}


/**
The starting index of grid lines along the axis
*/Aaxis & Tick0(const double &tick0 ) {
    _aaxis.insert({"tick0", tick0});
    return *this;
}


/**
Sets the angle of the tick labels with respect to the horizontal. For example, a `tickangle` of -90 draws the tick labels vertically.
*/Aaxis & Tickangle(const json11::Json::object &tickangle ) {
    _aaxis.insert({"tickangle", tickangle});
    return *this;
}


Aaxis & Tickfont(const CppPlotly::Trace::carpet::aaxis::Tickfont &tickfont ) {
    _aaxis.insert({"tickfont", tickfont});
    return *this;
}


/**
Sets the tick label formatting rule using d3 formatting mini-languages which are very similar to those in Python. For numbers, see: https://github.com/d3/d3-format/blob/master/README.md#locale_format And for dates see: https://github.com/d3/d3-time-format/blob/master/README.md#locale_format We add one item to d3's date formatter: *%{n}f* for fractional seconds with n digits. For example, *2016-10-13 09:15:23.456* with tickformat *%H~%M~%S.%2f* would display *09~15~23.46*
*/Aaxis & Tickformat(const std::string &tickformat ) {
    _aaxis.insert({"tickformat", tickformat});
    return *this;
}


Aaxis & Tickformatstops(const std::vector<CppPlotly::Trace::carpet::aaxis::Tickformatstop> &tickformatstops ) {
    _aaxis.insert({"tickformatstops", tickformatstops});
    return *this;
}


Aaxis & Tickmode(const json11::Json::object &tickmode ) {
    _aaxis.insert({"tickmode", tickmode});
    return *this;
}


/**
Sets a tick label prefix.
*/Aaxis & Tickprefix(const std::string &tickprefix ) {
    _aaxis.insert({"tickprefix", tickprefix});
    return *this;
}


/**
Sets a tick label suffix.
*/Aaxis & Ticksuffix(const std::string &ticksuffix ) {
    _aaxis.insert({"ticksuffix", ticksuffix});
    return *this;
}


/**
Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*. Used with `tickvals`.
*/Aaxis & Ticktext(const std::vector<double> &ticktext ) {
    _aaxis.insert({"ticktext", ticktext});
    return *this;
}


/**
Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*. Used with `tickvals`.
*/Aaxis & Ticktext(const std::vector<std::string> &ticktext ) {
    _aaxis.insert({"ticktext", ticktext});
    return *this;
}


/**
Sets the text displayed at the ticks position via `tickvals`. Only has an effect if `tickmode` is set to *array*. Used with `tickvals`.
*/Aaxis & Ticktext(const json11::Json::object &ticktext ) {
    _aaxis.insert({"ticktext", ticktext});
    return *this;
}


/**
Sets the source reference on plot.ly for  ticktext .
*/Aaxis & Ticktextsrc(const std::string &ticktextsrc ) {
    _aaxis.insert({"ticktextsrc", ticktextsrc});
    return *this;
}


/**
Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with `ticktext`.
*/Aaxis & Tickvals(const std::vector<double> &tickvals ) {
    _aaxis.insert({"tickvals", tickvals});
    return *this;
}


/**
Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with `ticktext`.
*/Aaxis & Tickvals(const std::vector<std::string> &tickvals ) {
    _aaxis.insert({"tickvals", tickvals});
    return *this;
}


/**
Sets the values at which ticks on this axis appear. Only has an effect if `tickmode` is set to *array*. Used with `ticktext`.
*/Aaxis & Tickvals(const json11::Json::object &tickvals ) {
    _aaxis.insert({"tickvals", tickvals});
    return *this;
}


/**
Sets the source reference on plot.ly for  tickvals .
*/Aaxis & Tickvalssrc(const std::string &tickvalssrc ) {
    _aaxis.insert({"tickvalssrc", tickvalssrc});
    return *this;
}


/**
Sets the title of this axis.
*/Aaxis & Title(const std::string &title ) {
    _aaxis.insert({"title", title});
    return *this;
}


Aaxis & Titlefont(const CppPlotly::Trace::carpet::aaxis::Titlefont &titlefont ) {
    _aaxis.insert({"titlefont", titlefont});
    return *this;
}


/**
An additional amount by which to offset the title from the tick labels, given in pixels
*/Aaxis & Titleoffset(const double &titleoffset ) {
    _aaxis.insert({"titleoffset", titleoffset});
    return *this;
}




    json11::Json to_json() const {
        return _aaxis;
    }

    private:

    json11::Json::object _aaxis;

    };

    }

    }
}
